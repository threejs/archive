<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="utf-8" />
		<base href="../../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>[name]</h1>

		<p class="desc">
			WebGL Render 用[link:https://en.wikipedia.org/wiki/WebGL WebGL]渲染出你精心制作的场景。
		</p>

		<h2>构造器</h2>

		<h3>[name]( [param:Object parameters] )</h3>
		<p>
		[page:Object parameters] - (可选) 该对象的属性定义了渲染器的行为。也可以完全不传参数。在所有情况下，当缺少参数时，它将采用合理的默认值。
			以下是合法参数：<br /><br />

		[page:DOMElement canvas] - 一个供渲染器绘制其输出的[link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas canvas]
		它和下面的[page:WebGLRenderer.domElement domElement]属性对应。
		如果没有传这个参数，会创建一个新canvas<br />


		[page:WebGLRenderingContext context] - 可用于将渲染器附加到已有的渲染环境([link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext RenderingContext])中。默认值是null<br />

		[page:String precision] - 着色器精度. 可以是 *"highp"*, *"mediump"* 或者 *"lowp"*.
		如果设备支持，默认为*"highp"* .<br />

		[page:Boolean alpha] - 控制默认的透明 alpha 值。设置为 *true* 时，值为 *0*。否则为 *1*。默认为 *false*。<br />

		[page:Boolean premultipliedAlpha] - renderer是否假设颜色有
		[link:https://en.wikipedia.org/wiki/Glossary_of_computer_graphics#Premultiplied_alpha premultiplied alpha].
		默认为*true* <br />

		[page:Boolean antialias] - 是否执行抗锯齿。默认为*false*.<br />

		[page:Boolean stencil] - 绘图缓存是否有一个至少8位的模板缓存([link:https://en.wikipedia.org/wiki/Stencil_buffer stencil buffer])。默认为*false*<br />

		[page:Boolean preserveDrawingBuffer] -是否保留缓直到手动清除或被覆盖。 默认*false*.<br />

		[page:String powerPreference] - 提示用户代理怎样的配置更适用于当前WebGL环境。 可能是*"high-performance"*, *"low-power"* 或 *"default"*。默认是*"default"*.
		详见[link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12 WebGL spec]<br />

		[page:Boolean failIfMajorPerformanceCaveat] - 检测渲染器是否会因性能过差而创建失败。默认为false。详见 [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12 WebGL spec] for details.<br />

		[page:Boolean depth] - 绘图缓存是否有一个至少6位的深度缓存([link:https://en.wikipedia.org/wiki/Z-buffering depth buffer] )。
		默认是*true*.<br />

		[page:Boolean logarithmicDepthBuffer] -  是否使用对数深度缓存。如果要在单个场景中处理巨大的比例差异，就有必要使用。
		请注意，此设置使用 gl_FragDepth（如果可用），这会禁用早期 [link:https://www.khronos.org/opengl/wiki/Early_Fragment_Test Early Fragment Test] 优化并可能导致性能下降。
		默认是 *false*。 示例：[example:webgl_camera_logarithmicdepthbuffer camera / logarithmicdepthbuffer]<br />

		[page:Boolean reverseDepthBuffer] - 是否使用反向深度缓冲区。需要 `EXT_clip_control` 扩展。
		该版本相较于对数深度缓冲区，速度更快、精度更高。默认值为 `false`。

		</p>

		<h2>属性</h2>

		<h3>[property:Boolean autoClear]</h3>
		<p>定义渲染器是否在渲染每一帧之前自动清除其输出。</p>


		<h3>[property:Boolean autoClearColor]</h3>
		<p>
			如果[page:.autoClear autoClear]为true, 定义renderer是否清除颜色缓存。
			默认是*true*
		</p>


		<h3>[property:Boolean autoClearDepth]</h3>
		<p>
			如果[page:.autoClear autoClear]是true, 定义renderer是否清除深度缓存。
			默认是*true*
		</p>


		<h3>[property:Boolean autoClearStencil]</h3>
		<p>
			如果[page:.autoClear autoClear]是true, 定义renderer是否清除模板缓存.
			默认是*true*
		</p>

		<h3>[property:Object capabilities]</h3>
		<p>
			一个包含当前渲染环境([link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext RenderingContext])的功能细节的对象。<br />

		- [page:Boolean floatFragmentTextures]: 环境是否支持[link:https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float OES_texture_float]扩展<br />
		- [page:Boolean floatVertexTextures]: 如果[page:Boolean floatFragmentTextures]和[page:Boolean vertexTextures]都是true， 则此值为*true* <br />
		- [page:Method getMaxAnisotropy](): 返回最大可用各向异性。<br />
		- [page:Method getMaxPrecision](): 返回顶点着色器和片元着色器的最大可用精度。 <br />
		- [page:Boolean isWebGL2]: 如果使用的上下文是 WebGL2RenderingContext 对象，则为 *true*。<br />
		- [page:Boolean logarithmicDepthBuffer]: 如果[page:parameter logarithmicDepthBuffer]在构造器中被设为true且
		环境支持[link:https://developer.mozilla.org/en-US/docs/Web/API/EXT_frag_depth EXT_frag_depth]扩展，则此值为*true*<br />
		- [page:Integer maxAttributes]: *gl.MAX_VERTEX_ATTRIBS*的值<br />
		- [page:Integer maxCubemapSize]: *gl.MAX_CUBE_MAP_TEXTURE_SIZE*的值，着色器可使用的立方体贴图纹理的最大 宽度*高度。<br />
		- [page:Integer maxFragmentUniforms]: *gl.MAX_FRAGMENT_UNIFORM_VECTORS*的值，片元着色器可使用的全局变量(uniforms)数量<br />
		- [page:Integer maxSamples]: *gl.MAX_SAMPLES*的值。多重采样抗锯齿 (MSAA) 环境下的最大样本数。<br />
		- [page:Integer maxTextureSize]: *gl.MAX_TEXTURE_SIZE*的值，着色器可使用纹理的最大 宽度*高度。<br />
		- [page:Integer maxTextures]: *gl.MAX_TEXTURE_IMAGE_UNITS*的值，着色器可使用的纹理数量<br />
		- [page:Integer maxVaryings]: *gl.MAX_VARYING_VECTORS*的值，着色器可使用矢量的数量<br />
		- [page:Integer maxVertexTextures]: *gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS*的值，顶点着色器可使用的纹理数量。<br />
		- [page:Integer maxVertexUniforms]: *gl.MAX_VERTEX_UNIFORM_VECTORS*的值，顶点着色器可使用的全局变量(uniforms)数量<br />
		- [page:String precision]: 渲染器当前使用的着色器的精度<br />
		- [page:Boolean vertexTextures]: 如果[property:Integer maxVertexTextures]大于0，此值为*true* (即可以使用顶点纹理)<br />
		</p>

		<h3>[property:Array clippingPlanes]</h3>
		<p>
			用户自定义的剪裁平面，在世界空间中被指定为THREE.Plane对象。
			这些平面全局使用。空间中与该平面点积为负的点将被切掉。
			默认值是[]
		</p>

		<h3>[property:Object debug]</h3>
		<p>
		- [page:Boolean checkShaderErrors]:
			如果为true，定义是否检查材质着色器程序
			编译和链接过程中的错误。 禁用此检查生产以获得性能增益可能很有用。
			强烈建议在开发期间保持启用这些检查。
			如果着色器没有编译和链接 - 它将无法工作，并且相关材料将不会呈现。
			默认是*true*</br>
		- [page:Function onShaderError]( gl, program, glVertexShader, glFragmentShader ):
		  一个可用于自定义错误报告的回调函数。该回调函数接收 WebGL 上下文、一个 WebGLProgram 实例以及两个分别代表顶点着色器和片段着色器的 WebGLShader 实例。
			指定自定义函数将禁用默认错误报告。默认值为 `null`。
		</p>

		<h3>[property:DOMElement domElement]</h3>
		<p>
		一个[link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas canvas]，渲染器在其上绘制输出。<br />
		渲染器的构造函数会自动创建(如果没有传入canvas参数);你需要做的仅仅是像下面这样将它加页面里去:<br />
		<code>
			document.body.appendChild( renderer.domElement );
		</code>
	  </p>

		<h3>[property:Object extensions]</h3>
		<p>
		- [page:Object get]( [param:String extensionName] ):
			用于检查是否支持各种扩展，并返回一个对象，其中包含扩展的详细信息。
			该方法检查以下扩展：<br />
		</p>

		<ul>
			<li>*WEBGL_depth_texture*</li>
			<li>*EXT_texture_filter_anisotropic*</li>
			<li>*WEBGL_compressed_texture_s3tc*</li>
			<li>*WEBGL_compressed_texture_pvrtc*</li>
			<li>*WEBGL_compressed_texture_etc1*</li>
			<li>查看更多：<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Using_Extensions#extension_list" target="_blank">Extension list</a></li>
		</ul>

		<p>
			- [page:Boolean has]( [param:String extensionName] ): 如果支持该扩展则返回 `true`。
		</p>

		<h3>[property:string outputColorSpace]</h3>
		<p>定义渲染器的输出编码。默认为[page:Textures THREE.SRGBColorSpace]</p>
		<p>如果渲染目标已经使用 [page:WebGLRenderer.setRenderTarget .setRenderTarget]、之后将直接使用renderTarget.texture.colorSpace</p>
		<p>查看[page:Textures texture constants]页面以获取其他格式细节</p>

		<h3>[property:Object info]</h3>
		<p>一个对象，包含有关图形板内存和渲染过程的一系列统计信息。这些信息可用于调试或仅仅满足下好奇心。该对象包含以下字段:</p>
		<p>
		<ul>
			<li>memory:
				<ul>
					<li>geometries</li>
					<li>textures</li>
				</ul>
			</li>
			<li>render:
				<ul>
					<li>calls</li>
					<li>triangles</li>
					<li>points</li>
					<li>lines</li>
					<li>frame</li>
				</ul>
			</li>
			<li>programs
			</li>
		</ul>
		</p>
		<p>默认情况下，这些字段在每次渲染调用时都会重置，但是当每帧有多个渲染通道时（例如，使用后处理时），最好使用自定义模式重置。先将 autoReset 设置为 false.
		<code>
		renderer.info.autoReset = false;
		</code>
		然后在单个帧时渲染完成后调用 reset().
		<code>
		renderer.info.reset();
		</code>
		</p>

		<h3>[property:Boolean localClippingEnabled]</h3>
		<p>定义渲染器是否考虑对象级剪切平面。 默认为*false*.</p>

		<h3>[property:Object properties]</h3>
		<p>
		渲染器内部使用，以跟踪各种子对象属性。
		</p>

		<h3>[property:WebGLRenderLists renderLists]</h3>
		<p>
		在内部用于处理场景渲染对象的排序。
		</p>

		<h3>[property:WebGLShadowMap shadowMap]</h3>
		<p>
		如果使用，它包含阴影贴图的引用。<br />
		- [page:Boolean enabled]:
			如果设置开启，允许在场景中使用阴影贴图。默认是 *false*。<br />
		- [page:Boolean autoUpdate]:
			启用场景中的阴影自动更新。默认是*true*<br />
			如果不需要动态光照/阴影, 则可以在实例化渲染器时将之设为false<br />
		- [page:Boolean needsUpdate]:
			当被设为*true*, 场景中的阴影贴图会在下次*render*调用时刷新。默认是*false* <br />
			如果你已经禁用了阴影贴图的自动更新(*shadowMap.autoUpdate = false*), 那么想要在下一次渲染时更新阴影的话就需要将此值设为*true*<br />
		- [page:Integer type]:
			定义阴影贴图类型 (未过滤, 关闭部分过滤, 关闭部分双线性过滤), 可选值有:
			<ul>
				<li>THREE.BasicShadowMap</li>
				<li>THREE.PCFShadowMap (默认)</li>
				<li>THREE.PCFSoftShadowMap</li>
				<li>THREE.VSMShadowMap</li>
			</ul>
			详见[page:Renderer Renderer constants]<br />

		<h3>[property:Boolean sortObjects]</h3>
		<p>
		定义渲染器是否应对对象进行排序。默认是*true*.<br /><br />

		说明: 排序用于尝试正确渲染出具有一定透明度的对象。根据定义，排序可能不总是有用。根据应用的需求，可能需要关闭排序并使其他方法来处理透明度的渲染，例如，
		手动确定每个对象的渲染顺序。
		</p>

		<h3>[property:Object state]</h3>
		<p>
		包含设置[page:WebGLRenderer.context]状态的各种属性的函数。
		</p>

		<h3>[property:Constant toneMapping]</h3>
		<p>
		默认是[page:Renderer NoToneMapping]。查看[page:Renderer Renderer constants]以获取其它备选项
		</p>

		<h3>[property:Number toneMappingExposure]</h3>
		<p>
		色调映射的曝光级别。默认是*1*
		</p>

		<h3>[property:Number transmissionResolutionScale]</h3>
		<p>传输渲染目标的标准化分辨率比例，以视口尺寸的百分比衡量。降低此值可以显著提升 [page:MeshPhysicalMaterial MeshPhysicalMaterial] 的传输性能。默认值为 `1`。
		</p>

		<h3>[property:WebXRManager xr]</h3>
		<p>
		提供对渲染器的 WebXR 相关 [page:WebXRManager interface] 的访问。
		</p>

		<h2>方法</h2>

		<h3>[method:undefined clear]( [param:Boolean color], [param:Boolean depth], [param:Boolean stencil] )</h3>
		<p>
		告诉渲染器清除颜色、深度或模板缓存.
		此方法将颜色缓存初始化为当前颜色。参数们默认都是*true*
		</p>

		<h3>[method:undefined clearColor]( )</h3>
		<p>清除颜色缓存。 相当于调用[page:WebGLRenderer.clear .clear]( true, false, false )</p>

		<h3>[method:undefined clearDepth]( )</h3>
		<p>清除深度缓存。相当于调用[page:WebGLRenderer.clear .clear]( false, true, false )</p>

		<h3>[method:undefined clearStencil]( )</h3>
		<p>清除模板缓存。相当于调用[page:WebGLRenderer.clear .clear]( false, false, true )</p>

		<h3>[method:Set compile]( [param:Object3D scene], [param:Camera camera], [param:Scene targetScene] )</h3>
		<p>
			使用相机编译场景中的所有材质。这对于在首次渲染之前预编译着色器很有用。
			如果要将 3D 对象添加到现有场景，请使用第三个可选参数来应用目标场景。<br />
			请注意，在调用此方法之前应配置场景的照明。
		</p>

		<h3>[method:Promise compileAsync]( [param:Object3D scene], [param:Camera camera], [param:Scene targetScene] )</h3>
		<p>
			[page:WebGLRenderer.compile .compile]() 的异步版本。该方法返回一个 Promise。它解决了何时可以渲染给定的 3D 对象或场景，而不会因着色器编译而出现不必要的停顿。<br /><br />
			此方法利用 *KHR_parallel_shader_compile*。
		</p>

		<h3>[method:undefined copyFramebufferToTexture]( [param:FramebufferTexture texture], [param:Vector2 position], [param:Number level] )</h3>
		<p>将当前WebGLFramebuffer中的像素复制到2D纹理中。可访问[link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/copyTexImage2D WebGLRenderingContext.copyTexImage2D].</p>

		<h3>[method:undefined copyTextureToTexture]( [param:Texture srcTexture], [param:Texture dstTexture], [param:Box2 srcRegion], [param:Vector2 dstPosition], [param:Number level] )</h3>
		<p>
			从指定位置开始，复制目标纹理中 '[page:Box3 srcRegion]' 边界内的纹理像素。
			2D 纹理、3D 纹理或两者的混合可以用作源纹理和目标纹理参数，以便在 3D 纹理层之间进行复制。</br>
			渲染目标的 `depthTexture` 和 `texture` 属性也受支持。<br />
			使用渲染目标纹理作为 `depthTexture` 和 `texture` 时，必须确保两个渲染目标都已初始化，例如通过 [page:.initRenderTarget]() 初始化。
		</p>

		<h3>[method:undefined dispose]( )</h3>
		<p>释放此实例分配的 GPU 相关资源。每当您的应用中不再使用此实例时，请调用此方法。</p>

		<h3>[method:undefined forceContextLoss]()</h3>
		<p>
		模拟WebGL环境的丢失。需要支持
			[link:https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context WEBGL_lose_context] 扩展才能用。
		</p>

		<h3>[method:undefined forceContextRestore]( )</h3>
		<p>
		模拟WebGL环境的恢复。需要支持
			[link:https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context WEBGL_lose_context] 扩展才能用。
		</p>

		<h3>[method:Float getClearAlpha]()</h3>
		<p>返回一个表示当前alpha值的[page:Float float]，范围0到1</p>

		<h3>[method:Color getClearColor]( [param:Color target] )</h3>
		<p>返回一个表示当前颜色值的[page:Color THREE.Color]实例</p>

		<h3>[method:WebGL2RenderingContext getContext]()</h3>
		<p>返回当前WebGL环境</p>

		<h3>[method:WebGLContextAttributes getContextAttributes]()</h3>
		<p>返回一个对象，这个对象中存有在WebGL环境在创建的时候所设置的属性</p>

		<h3>[method:Integer getActiveCubeFace]()</h3>
		<p>返回当前活动的立方体面。</p>

		<h3>[method:Integer getActiveMipmapLevel]()</h3>
		<p>返回当前活动的 mipmap 级别。</p>

		<h3>[method:RenderTarget getRenderTarget]()</h3>
		<p>如果当前存在[page:RenderTarget RenderTarget]，则返回该值；否则返回*null*。</p>

		<h3>[method:RenderTarget getCurrentViewport]()</h3>
		<p>返回当前视口</p>

		<h3>[method:Object getDrawingBufferSize]()</h3>
		<p>返回一个包含渲染器绘图缓存宽度和高度(单位像素)的对象。</p>

		<h3>[method:number getPixelRatio]()</h3>
		<p>返回当前使用设备像素比</p>

		<h3>[method:Vector4 getScissor]( [param:Vector4 target] )</h3>
		<p>
			[page:Vector4 target] — 结果将被复制到这个 Vector4 中。<br /><br />

			返回剪裁区域。
		</p>

		<h3>[method:Boolean getScissorTest]()</h3>
		<p>如果启用了剪裁测试，则返回 `true`；否则返回 `false`。</p>

		<h3>[method:Vector2 getSize]( [param:Vector2 target] )</h3>
		<p>返回包含渲染器输出canvas的宽度和高度(单位像素)的对象。</p>
		
		<h3>[method:Vector4 getViewport]( [param:Vector4 target] )</h3>
		<p>
			[page:Vector4 target] — 结果将被复制到这个 Vector4 中。<br /><br />

			返回视口。
		</p>

		<h3>[method:undefined initTexture]( [param:Texture texture] )</h3>
		<p>初始化给定的纹理。用于预加载纹理而不是等到第一次渲染（可能会由于解码和 GPU 上传的开销而导致明显的延迟）.</p>

		<h3>[method:undefined initRenderTarget]( [param:WebGLRenderTarget target] )</h3>
		<p>
			初始化给定的 WebGLRenderTarget 内存。用于初始化渲染目标，以便在渲染之前使用 [page:WebGLRenderer.copyTextureToTexture .copyTextureToTexture] 将数据复制到渲染目标中。
		</p>

		<h3>[method:undefined resetGLState]( )</h3>
		<p>将GL状态重置为默认值。WebGL环境丢失时会内部调用</p>

		<h3>[method:undefined readRenderTargetPixels]( [param:WebGLRenderTarget renderTarget], [param:Float x], [param:Float y], [param:Float width], [param:Float height], [param:TypedArray buffer], [param:Integer activeCubeFaceIndex] )</h3>
		<p>buffer - Uint8Array 是唯一在所有情况下都受支持的目标类型，其他类型则由 renderTarget 和平台决定。详情请参阅 [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12 WebGL spec] 规范。</p>
		<p>将renderTarget中的像素数据读取到传入的缓冲区中。这是[link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels WebGLRenderingContext.readPixels]()的包装器<br />
		示例：[example:webgl_interactive_cubes_gpu interactive / cubes / gpu]</p>
		<p>要读取 [page:WebGLCubeRenderTarget WebGLCubeRenderTarget]，请使用可选参数 activeCubeFaceIndex 来确定应该读取哪个面。</p>

		<h3>
			[method:Promise readRenderTargetPixelsAsync]( [param:WebGLRenderTarget renderTarget], [param:Float x], [param:Float y], [param:Float width], [param:Float height], [param:TypedArray buffer], [param:Integer activeCubeFaceIndex] )
		</h3>
		<p>
			[page:WebGLRenderer.readRenderTargetPixels .readRenderTargetPixels] 的异步、非阻塞版本。一旦缓冲区数据可供使用，返回的 promise 就会解析。
		</p>
		<p>
			查看示例 [example:webgl_interactive_cubes_gpu interactive / cubes / gpu]。
		</p>

		<h3>[method:undefined render]( [param:Object3D scene], [param:Camera camera] )</h3>
		<p>
			用相机([page:Camera camera])渲染一个场景([page:Scene scene])或是其它类型的[page:Object3D object]。<br />

			渲染一般是在canvas上完成的，或者是[page:WebGLRenderTarget renderTarget](通过[page:WebGLRenderer.setRenderTarget .setRenderTarget]指定)。<br />

			默认情况下渲染缓存是会被清除的，但是你可以通过设置[page:WebGLRenderer.autoClear autoClear] 属性的值为false来阻止渲染缓存被清除。
			如果你想阻止某个指定的缓存被清空，可以设置[page:WebGLRenderer.autoClearColor autoClearColor]、[page:WebGLRenderer.autoClearStencil autoClearStencil]或[page:WebGLRenderer.autoClearDepth autoClearDepth]属性的值为false来阻止其被清除。
			如果想要强制清除一个或多个缓存，可以调用[page:WebGLRenderer.clear .clear]。
		</p>

		<h3>[method:undefined resetState]()</h3>
		<p>可用于重置内部 WebGL 状态。此方法主要与跨多个 WebGL 库共享单个 WebGL 上下文的应用程序相关。</p>

		<h3>[method:undefined setAnimationLoop]( [param:Function callback] )</h3>
		<p>[page:Function callback] — 每个可用帧都会调用的函数。 如果传入‘null’,所有正在进行的动画都会停止。</p>
		<p>可用来代替[link:https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame requestAnimationFrame]的内置函数. 对于WebXR项目，必须使用此函数。</p>

		<h3>[method:undefined setClearAlpha]( [param:Float alpha] )</h3>
		<p>设置alpha。合法参数是一个*0.0*到 *1.0*之间的浮点数</p>

		<h3>[method:undefined setClearColor]( [param:Color color], [param:Float alpha] )</h3>
		<p>设置颜色及其透明度</p>

		<h3>[method:undefined setPixelRatio]( [param:number value] )</h3>
		<p>设置设备像素比。通常用于避免HiDPI设备上绘图模糊</p>

		<h3>[method:undefined setRenderTarget]( [param:WebGLRenderTarget renderTarget], [param:Integer activeCubeFace], [param:Integer activeMipmapLevel] )</h3>
		<p>
		renderTarget -- (可选参数) 需要被激活的[page:WebGLRenderTarget renderTarget]。若此参数为空，则将canvas设置成活跃render target。<br />
		activeCubeFace -- (可选参数) 指定 [page:WebGLCubeRenderTarget] 当前激活的立方体面(PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5)。
		当传递 [page:WebGLArrayRenderTarget] 或 [page:WebGL3DRenderTarget] 时，此参数指示要渲染到的 z 层。<br />
		activeMipmapLevel -- (可选参数) 指定当前激活的 mipmap 级别。<br /><br />
		该方法设置活跃rendertarget。
		</p>

		<h3>
			[method:undefined setScissor]( [param:Integer x], [param:Integer y], [param:Integer width], [param:Integer height] )<br />
			[method:undefined setScissor]( [param:Vector4 vector] )
		</h3>
		<p>
		根据 x、y、width 和 height 参数设置剪裁区域。<br />
		也可以选择使用 Vector4 的 4 个分量来设置。<br /><br />

		将剪裁区域设为 (x, y) 到 (x + width, y + height)。<br />
		(x, y) 是剪裁区域的左下角。
		</p>

		<h3>[method:undefined setScissorTest]( [param:Boolean boolean] )</h3>
		<p>
		启用或禁用剪裁检测. 若启用，则只有在所定义的裁剪区域内的像素才会受之后的渲染器影响。
		</p>

		<h3>[method:undefined setSize]( [param:Integer width], [param:Integer height], [param:Boolean updateStyle] )</h3>
		<p>
		将输出canvas的大小调整为(width, height)并考虑设备像素比，且将视口从(0, 0)开始调整到适合大小
		将[page:Boolean updateStyle]设置为false以阻止对canvas的样式做任何改变。
		</p>

		<h3>[method:undefined setViewport]( [param:Integer x], [param:Integer y], [param:Integer width], [param:Integer height] )</h3>
		<p>将视口大小设置为(x, y)到 (x + width, y + height).</p>

		<h2>源码</h2>

		<p>
			[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
		</p>
	</body>
</html>
