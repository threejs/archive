<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="utf-8" />
		<base href="../../../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>

		<h1>[name]</h1>

		<p class="desc">
			该类作为其他阴影类的基类来使用。
		</p>


		<h2>构造函数</h2>

		<h3>[name]( [param:Camera camera] )</h3>
		<p>
		[page:Camera camera] - 在光的世界里<br /><br />

			创建一个新的[name]。这不能直接调用的 - 它由其他阴影用作基类。
		</p>

		<h2>属性</h2>

		<h3>[property:Boolean autoUpdate]</h3>
		<p>
			启用光源阴影的自动更新。默认值为 *true*。如果您不需要动态光照/阴影，可以将其设置为 *false*。
		</p>

		<h3>[property:Camera camera]</h3>
		<p>
			光的世界里。这用于生成场景的深度图;从光的角度来看，其他物体背后的物体将处于阴影中。
		</p>

		<h3>[property:Float bias]</h3>
		<p>
			阴影贴图偏差，在确定曲面是否在阴影中时，从标准化深度添加或减去多少。<br />
			默认值为0.此处非常小的调整（大约0.0001）可能有助于减少阴影中的伪影
		</p>

		<h3>[property:Integer blurSamples]</h3>
		<p>
			模糊 VSM 阴影贴图时使用的样本数量。
		</p>

		<h3>[property:Float intensity]</h3>
		<p>
			阴影的强度。默认值为 `1`。有效值范围为 `[0, 1]`。
		</p>

		<h3>[property:WebGLRenderTarget map]</h3>
		<p>
			使用内置相机生成的深度图;超出像素深度的位置在阴影中。在渲染期间内部计算。
		</p>

		<h3>[property:WebGLRenderTarget mapPass]</h3>
		<p>
			使用内部相机生成的分布图；遮挡是根据深度分布计算的。渲染期间进行内部计算。
		</p>

		<h3>[property:Vector2 mapSize]</h3>
		<p>
			一个[Page:Vector2]定义阴影贴图的宽度和高度。<br /><br />

			较高的值会以计算时间为代价提供更好的阴影质量。值必须是2的幂，直到给定设备的[page:WebGLRenderer.capabilities].maxTextureSize，
			虽然宽度和高度不必相同（例如，（512,1024）有效）。
			默认值为*（512,512）*。
		</p>


		<h3>[property:Matrix4 matrix]</h3>
		<p>
			模拟阴影相机空间，计算阴影贴图中的位置和深度。存储在[page:Matrix4 Matrix4]中。这是在渲染期间内部计算的。
		</p>

		<h3>[property:Boolean needsUpdate]</h3>
		<p>
			设置为 *true* 时，阴影贴图将在下一次渲染调用中更新。
			默认值为 *false*。如果您已将 [page:.autoUpdate] 设置为 *false*，则需要将此属性设置为 *true*，然后进行渲染调用来更新光源的阴影。
		</p>

		<h3>[property:Float normalBias]</h3>
		<p>
			定义用于查询阴影贴图的位置沿对象法线的偏移量。默认值为 0。
			增加此值可用于减少阴影瑕疵，尤其是在光线以较小角度照射几何体的大型场景中。但代价是阴影可能会出现扭曲。
		</p>

		<h3>[property:Float radius]</h3>
		<p>
			将此值设置为大于1的值将模糊阴影的边缘。<br />

			较高的值会在阴影中产生不必要的条带效果 - 更大的[page:.mapSize mapSize]将允许在这些效果变得可见之前使用更高的值。<br />
			如果 [page:WebGLRenderer.shadowMap.type] 设置为 [page:Renderer PCFSoftShadowMap]，则半径无效，建议通过减小 [page:.mapSize mapSize] 来增加柔和度。<br /><br />

			请注意，如果[page：WebGLRenderer.shadowMap.type]设置为[page:Renderer BasicShadowMap]，将会无效。
		</p>


		<h2>方法</h2>

		<h3>[method:Vector2 getFrameExtents]()</h3>
		<p>
		由渲染器内部使用，以扩展阴影贴图以包含所有视口。
		</p>

		<h3>[method:undefined updateMatrices]( [param:Light light] )</h3>
		<p>
		更新渲染器内部使用的相机和阴影的矩阵。<br /><br />

		light -- 渲染阴影的光源。
		</p>

		<h3>[method:Frustum getFrustum]()</h3>
		<p>
		获取阴影摄像机的视锥体。渲染器内部使用它来剔除对象。
		</p>

		<h3>[method:number getViewportCount]()</h3>
		<p>
		由渲染器内部使用，以获取需要为此阴影渲染的视口数量。
		</p>

		<h3>[method:this copy]( [param:LightShadow source] )</h3>
		<p>
			将[page:LightShadow source]中的所有属性的值复制到该Light。
		</p>

		<h3>[method:LightShadow clone]()</h3>
		<p>
			克隆与此相同属性的新LightShadow。
		</p>

		<h3>[method:Object toJSON]()</h3>
		<p>
			序列化这个LightShadow。
		</p>

		<h2>源码</h2>
		<p>
			[link:https://github.com/mrdoob/three.js/blob/master/src/lights/[name].js src/lights/[name].js]
		</p>
	</body>
</html>
